---
title: 面试复习
tag: 面试
reward: true
---
## Java基础
<!-- more -->

### 容器

#### Map

1.  HashMap
	1.  默认大小, 扩容
	2.  hash冲突
	3.  链表/红黑树
	4.  多线程操作, 1.7死循环
3.  ConcurrentHashMap
	1.  并发原理
	2.  1.7和1.8对比
4.  HashTable
	1.  并发原理
5.  TreeMap
	1.  底层结构
6.  红黑树
	1.  基本定义
	2.  插入思想
	3.  https://www.jianshu.com/p/e136ec79235c
	4.  对比AVL

#### Collection

1.  ArrayList
	1.  默认大小, 扩容(10, 1.5)
	2.  对比LinkedList, Vector
	3.  获取数据O(1), 扩容O(1)
2.  LinkedList
	1.  基本结构
3.  Vector
	1.  并发原理
4.  CopyOnWriteList
	1.  基本结构
	2.  并发原理
5.  HashSet
	1.  基本结构
6.  ConcurrentHashSet
7.  Queue/Deque
	1.  api
8. PriorityQueue
	1.  堆

### 并发
#### 线程
1. http://ifeve.com/java-concurrency-thread-directory/
2. https://www.cnblogs.com/java1024/archive/2019/11/28/11950129.html
3. https://www.cnblogs.com/zhanht/p/5450325.html
4. java中线程的状态
    1. https://blog.csdn.net/qq_22771739/article/details/82529874
5. 线程池
    1. http://ifeve.com/java-threadpool/
    2. https://yq.aliyun.com/articles/687794
   3. https://blog.51cto.com/14230003/2418026?source=dra
   4. https://blog.csdn.net/weixin_28760063/article/details/81266152
   5. https://www.cnblogs.com/a8457013/p/7819044.html
   6. https://www.cnblogs.com/x-bing/p/5680611.html
   7. https://www.jianshu.com/p/174958a72ce9
    8. 创建, 参数
        1. 线程池大小: https://blog.csdn.net/qrne06/article/details/80587576
        2. https://www.cnblogs.com/gujiande/p/9488462.html
        3. https://www.cnblogs.com/fengzheng/p/9297602.html
    9. 基本原理
        1. 执行流程
            1. 带看源码
            2. 处理任务判断的优先级为 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务
                1. 如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。
                2. 如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。
                3. 如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。
                4. 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。
                5. 当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。
       2. Worker的创建和释放
          1. 带看源码
   10. Runnable, Callable
       1. https://blog.csdn.net/weixin_30514745/article/details/95664175
       2. https://blog.51cto.com/4837471/2327284
       3. 带看FutureTask源码
   11. submit, execute
       1. submit() 该方法返回一个Future对象，可执行带返回值的线程；或者执行想随时可以取消的线程。Future对象的get()方法获取返回值。Future对象的cancel(true/false)取消任务，未开始或已完成返回false，参数表示是否中断执行中的线程
       2. execute() 没有返回值。
   12. Executors提供的几种线程池和队列
       1. https://blog.csdn.net/weixin_40304387/article/details/80508236
       2. newCachedThreadPool
          1. https://www.zhihu.com/question/23212914
          2. SynchronousQueue
          3. https://zhuanlan.zhihu.com/p/29227508
   13. 定时任务, ScheduledThreadPoolExecutor
       1. DelayedWorkQueue
          1. 最小堆
          2. 看源码

#### 锁, JUC
1. CAS, ABA
   1. https://blog.csdn.net/wufaliang003/article/details/78797203
   2. UNSAFE, 带看源码
2. synchronized
   1. https://www.jianshu.com/p/36eedeb3f912
   2. https://www.jianshu.com/p/9998a9db17f7
   3. https://www.jianshu.com/p/31b6a0b1b84b
   4. https://blog.csdn.net/aiyawalie/article/details/53261823
   5. ![](https://ilio.tech/images/4491294-e3bcefb2bacea224.png)
3. ReentrantLock
   1. https://cloud.tencent.com/developer/article/1414968
   2. https://baijiahao.baidu.com/s?id=1638104862611986445&wfr=spider&for=pc
   3. 公平/非公平
      1. 区别: 有没有排队
   4. ReentrantReadWriteLock
   5. 带看源码
4. AQS
   1. 带看源码
   2. CLH
      1. https://www.jianshu.com/p/1b1b44e84394
      2. https://www.jianshu.com/p/5ad8539e25c3
   3. [看到2.3即可](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484832&idx=1&sn=f902febd050eac59d67fc0804d7e1ad5&chksm=cea24a6bf9d5c37d6b505fe1d43e4fb709729149f1f77344b4a0f5956cab5020a2e102f2adf2&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)
   4. 独占, 共享: ReentrantReadWriteLock
5. Latch, Barrier, Semaphore
   1. CountDownLatch
      1. https://blog.csdn.net/u012637358/article/details/90288585
      2. https://www.cnblogs.com/fengzheng/p/9153720.html
   2. CyclicBarrier
      1. https://www.jdon.com/idea/java/Java-cyclicbarrier.html
   3. Semaphore
      1. https://segmentfault.com/a/1190000019334692
6. volatile
   1. 两个功能
      1. 线程可见性: lock
         1. 通过lock, 
      2. 禁止重排序: 内存屏障
   2. https://www.jianshu.com/p/ef8de88b1343
   3. https://www.cnblogs.com/yaowen/p/11240540.html
   4. happen-before, 简读: http://www.voidcn.com/article/p-qzqvusbt-ke.html

#### JVM
1. 类加载过程
2. 内存模型
3. GC
 4. 回收算法
     1. 分代
    2. CMS, G1
    3. ZGC
5. 反射

## Redis
1. 数据类型, 底层结构
	1. string
	2. list
	3. set
	4. hash
	5. zset *
		1. 跳表和二叉树相比
2. 持久化
	1. RDB/AOF
	2. AOF过大怎么优化
	3. 通常RDB和AOF一起使用
3. 分布式锁
	1. 怎么避免主从不一致, RedLock
	2. 对比Zookeeper
4. 布隆过滤器
5. 缓存击穿, 穿透, 雪崩
6. 主从, 哨兵
	1. 主从同步

## MySQL
1. binlog
2. 主键id的策略, 不设置的处理方式
3. InnoDB, MyIsam
	1. 区别
4. 聚簇索引, 非聚簇索引, 区别, 原理
5. 普通索引, 联合索引, 结构
6. 索引优化, 失效场景
7. B树和B+树的区别
8. ACID的实现原理
	1. 原子性, undo log
	2. 一致性
	3. 隔离性, 隔离级别, MVCC
	4. 持久性, redo log
9. 四种隔离级别, 实现原理
10. MVCC, readview
11. 锁类型
	1. 意向锁 *
	2. 间隙锁 *
12. 缓存一致性
13. 主从复制
14. 转账
	1. 单向, A -> B
	2. 双向, A -> B & B -> A, 怎么避免死锁(不考虑锁机制)
	3. 设计转账系统
		1. 同步转账
		2. 异步转账

## 网络
1. https, 建立连接, 对称加密
2. tcp网络协议, 拥塞控制
3. 进程通信方法
4. NIO
	1. 原理
	2. epoll, select/poll对比
	3. epoll数据结构
5. session, cookie区别
6. 输入网址到返回结果的全部过程, 数据流转, 缓存, DNS, 后端处理, 转发

## 设计模式
1. http://c.biancheng.net/design_pattern/
2. http://www.cocoachina.com/articles/31808

## Spring
1. IOC
	1. BeanFactory
	2. ApplicationContext
	3. Bean的创建, 生命周期
	4. 声明Bean的方式
		1. 注解, @Component, @Bean
		2. XML
2. AOP
3. 动态代理
	1. JDK
	2. CGLIB
4. SpringBoot
	1. 基本思想
	2. starter原理, EnableAutoConfiguration
5. 设计模式
	1. 单例
	2. 工厂
	3. 代理
	4. 责任链, Filter
	5. 模板, RedisTemplate
	6. 策略, Interceptor
6. BeanFactory, FactoryBean
7. 事务
	1. 管理方式
		1. 编程式, 使用TransactionTemplate开启关闭和提交事务
		2. 声明式, @Transactional, XML
	2. 传播行为
8. 循环依赖
9. MyBatis

## 中间件
### Kafka
1. 数据存储, 流程
2. 高可用
3. 持久化
4. 消息队列, 重复消费, 事务消息
5. 顺序消费
	1. 借助数据库
	2. 监听器关闭消费者
6. 不同队列的对比

### Thrift


## 分布式
1. 缓存类型, 从客户端到服务端
2. 一致性Hash
3. 熔断, 限流, 降级
4. 微服务
5. 分布式调度
6. CAP
7. 分布式事务

## 项目
1. 如何找项目性能瓶颈
2. 项目亮点, 难题, 处理
