<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试复习</title>
      <link href="2021/01/08/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
      <url>2021/01/08/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><a id="more"></a><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ol><li>HashMap<ol><li>默认大小, 扩容</li><li>hash冲突</li><li>链表/红黑树</li><li>多线程操作, 1.7死循环</li></ol></li><li>ConcurrentHashMap<ol><li>并发原理</li><li>1.7和1.8对比</li></ol></li><li>HashTable<ol><li>并发原理</li></ol></li><li>TreeMap<ol><li>底层结构</li></ol></li><li>红黑树<ol><li>基本定义</li><li>插入思想</li><li><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">https://www.jianshu.com/p/e136ec79235c</a></li><li>对比AVL</li></ol></li></ol><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><ol><li>ArrayList<ol><li>默认大小, 扩容(10, 1.5)</li><li>对比LinkedList, Vector</li><li>获取数据O(1), 扩容O(1)</li></ol></li><li>LinkedList<ol><li>基本结构</li></ol></li><li>Vector<ol><li>并发原理</li></ol></li><li>CopyOnWriteList<ol><li>基本结构</li><li>并发原理</li></ol></li><li>HashSet<ol><li>基本结构</li></ol></li><li>ConcurrentHashSet</li><li>Queue/Deque<ol><li>api</li></ol></li><li>PriorityQueue<ol><li>堆</li></ol></li></ol><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ol><li>java中线程的状态</li><li>线程池<ol><li>基本参数</li><li>基本原理<ol><li>执行流程</li><li>Worker的创建和释放</li></ol></li><li>Executors提供的几种线程池和队列</li><li>定时任务</li></ol></li></ol><h4 id="锁-JUC"><a href="#锁-JUC" class="headerlink" title="锁, JUC"></a>锁, JUC</h4><ol><li>CAS, ABA<ol><li>UNSAFE</li><li><a href="https://ilio.tech/2019/09/08/Java%20%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/#more">https://ilio.tech/2019/09/08/Java%20%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/#more</a></li></ol></li><li>synchronized</li><li>ReentrantLock</li><li>AQS</li><li>volatile</li></ol><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ol><li>类加载过程</li><li>内存模型</li><li>GC<ol><li>回收算法</li><li>分代</li><li>CMS, G1</li><li>ZGC</li></ol></li></ol><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ol><li>数据类型, 底层结构<ol><li>string</li><li>list</li><li>set</li><li>hash</li><li>zset *<ol><li>跳表和二叉树相比</li></ol></li></ol></li><li>持久化<ol><li>RDB/AOF</li><li>AOF过大怎么优化</li><li>通常RDB和AOF一起使用</li></ol></li><li>分布式锁<ol><li>怎么避免主从不一致, RedLock</li><li>对比Zookeeper</li></ol></li><li>布隆过滤器</li><li>缓存击穿, 穿透, 雪崩</li><li>主从, 哨兵<ol><li>主从同步</li></ol></li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol><li>binlog</li><li>主键id的策略, 不设置的处理方式</li><li>InnoDB, MyIsam<ol><li>区别</li></ol></li><li>聚簇索引, 非聚簇索引, 区别, 原理</li><li>普通索引, 联合索引, 结构</li><li>索引优化, 失效场景</li><li>B树和B+树的区别</li><li>ACID的实现原理<ol><li>原子性, undo log</li><li>一致性</li><li>隔离性, 隔离级别, MVCC</li><li>持久性, redo log</li></ol></li><li>四种隔离级别, 实现原理</li><li>MVCC, readview</li><li>锁类型<ol><li>意向锁 *</li><li>间隙锁 *</li></ol></li><li>缓存一致性</li><li>主从复制</li><li>转账<ol><li>单向, A -&gt; B</li><li>双向, A -&gt; B &amp; B -&gt; A, 怎么避免死锁(不考虑锁机制)</li><li>设计转账系统<ol><li>同步转账</li><li>异步转账</li></ol></li></ol></li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>https, 建立连接, 对称加密</li><li>tcp网络协议, 拥塞控制</li><li>进程通信方法</li><li>NIO<ol><li>原理</li><li>epoll, select/poll对比</li><li>epoll数据结构</li></ol></li><li>session, cookie区别</li><li>输入网址到返回结果的全部过程, 数据流转, 缓存, DNS, 后端处理, 转发</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">http://c.biancheng.net/design_pattern/</a></li><li><a href="http://www.cocoachina.com/articles/31808" target="_blank" rel="noopener">http://www.cocoachina.com/articles/31808</a></li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol><li>IOC<ol><li>BeanFactory</li><li>ApplicationContext</li><li>Bean的创建, 生命周期</li><li>声明Bean的方式<ol><li>注解, @Component, @Bean</li><li>XML</li></ol></li></ol></li><li>AOP</li><li>动态代理<ol><li>JDK</li><li>CGLIB</li></ol></li><li>SpringBoot<ol><li>基本思想</li><li>starter原理, EnableAutoConfiguration</li></ol></li><li>设计模式<ol><li>单例</li><li>工厂</li><li>代理</li><li>责任链, Filter</li><li>模板, RedisTemplate</li><li>策略, Interceptor</li></ol></li><li>BeanFactory, FactoryBean</li><li>事务<ol><li>管理方式<ol><li>编程式, 使用TransactionTemplate开启关闭和提交事务</li><li>声明式, @Transactional, XML</li></ol></li><li>传播行为</li></ol></li><li>循环依赖</li><li>MyBatis</li></ol><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ol><li>数据存储, 流程</li><li>高可用</li><li>持久化</li><li>消息队列, 重复消费, 事务消息</li><li>顺序消费<ol><li>借助数据库</li><li>监听器关闭消费者</li></ol></li><li>不同队列的对比</li></ol><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ol><li>缓存类型, 从客户端到服务端</li><li>一致性Hash</li><li>熔断, 限流, 降级</li><li>微服务</li><li>分布式调度</li><li>CAP</li><li>分布式事务</li></ol><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol><li>如何找项目性能瓶颈</li><li>项目亮点, 难题, 处理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法库</title>
      <link href="2020/10/21/%E7%AE%97%E6%B3%95%E5%BA%93/"/>
      <url>2020/10/21/%E7%AE%97%E6%B3%95%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><a id="more"></a><hr><ul><li><input checked disabled type="checkbox"> 二叉树的层序遍历</li><li><input checked disabled type="checkbox"> LRU缓存机制</li><li><input checked disabled type="checkbox"> 字符串相加</li><li><input checked disabled type="checkbox"> 二叉树的右视图</li><li><input checked disabled type="checkbox"> 路径总和 II</li><li><input checked disabled type="checkbox"> 无重复字符的最长子串</li><li><input checked disabled type="checkbox"> K 个一组翻转链表</li><li><input checked disabled type="checkbox"> 两数相加</li><li><input checked disabled type="checkbox"> 二叉树的完全性检验</li><li><input checked disabled type="checkbox"> 连续子数组的最大和</li><li><input checked disabled type="checkbox"> 前 K 个高频元素</li><li><input checked disabled type="checkbox"> 对称二叉树</li><li><input disabled type="checkbox"> 段式回文</li><li><input checked disabled type="checkbox"> 有效的括号</li><li><input checked disabled type="checkbox"> 移动零</li><li><input checked disabled type="checkbox"> 链表的中间结点</li><li><input checked disabled type="checkbox"> LFU缓存</li><li><input checked disabled type="checkbox"> 反转链表</li><li><input checked disabled type="checkbox"> 相同的树</li><li><input checked disabled type="checkbox"> x 的平方根</li><li><input disabled type="checkbox"> 二叉树中的最大路径和</li><li><input checked disabled type="checkbox"> 旋转数组的最小数字</li><li><input checked disabled type="checkbox"> 相交链表</li><li><input checked disabled type="checkbox"> 三数之和</li><li><input disabled type="checkbox"> 重排链表</li><li><input checked disabled type="checkbox"> 字符串转换整数 (atoi)</li><li><input disabled type="checkbox"> 将数组拆分成斐波那契序列</li><li><input disabled type="checkbox"> 缺失的第一个正数</li><li><input checked disabled type="checkbox"> 二分查找</li><li><input disabled type="checkbox"> 最长连续序列</li><li><input disabled type="checkbox"> 二叉树剪枝</li><li><input checked disabled type="checkbox"> 二叉搜索树的后序遍历序列</li><li><input disabled type="checkbox"> 合并K个排序链表</li><li><input checked disabled type="checkbox"> 两数之和</li><li><input checked disabled type="checkbox"> 两数相加 II</li><li><input checked disabled type="checkbox"> 顺时针打印矩阵</li><li><input checked disabled type="checkbox"> 斐波那契数</li><li><input checked disabled type="checkbox"> 环形链表</li><li><input disabled type="checkbox"> 扑克牌中的顺子</li><li><input checked disabled type="checkbox"> 从前序与中序遍历序列构造二叉树</li><li><input checked disabled type="checkbox"> 数组中的第K个最大元素</li><li><input disabled type="checkbox"> 二叉树的最小深度</li><li><input disabled type="checkbox"> 腐烂的橘子</li><li><input checked disabled type="checkbox"> 二叉搜索树的第k大节点</li><li><input disabled type="checkbox"> 搜索旋转排序数组</li><li><input checked disabled type="checkbox"> 有序数组的平方</li><li><input checked disabled type="checkbox"> 回文链表</li><li><input checked disabled type="checkbox"> 二叉树的最大深度</li><li><input checked disabled type="checkbox"> 二叉树的直径</li><li><input checked disabled type="checkbox"> 合并两个有序链表</li><li><input checked disabled type="checkbox"> 翻转字符串里的单词</li><li><input checked disabled type="checkbox"> 整数反转</li><li><input checked disabled type="checkbox"> 二叉树的所有路径</li><li><input checked disabled type="checkbox"> 二叉树的锯齿形层次遍历</li><li><input disabled type="checkbox"> 二叉树最大宽度</li><li><input disabled type="checkbox"> 二叉树中和为某一值的路径</li><li><input disabled type="checkbox"> III. 从上到下打印二叉树 III</li><li><input disabled type="checkbox"> 最长上升子序列</li><li><input disabled type="checkbox"> 零钱兑换</li><li><input disabled type="checkbox"> 二叉树的完全性检验</li><li><input disabled type="checkbox"> 二叉树的最大深度</li><li><input disabled type="checkbox"> 平衡二叉树</li><li><input disabled type="checkbox"> II. 平衡二叉树</li><li><input disabled type="checkbox"> 二叉树剪枝</li><li><input checked disabled type="checkbox"> 不同路径</li><li><input checked disabled type="checkbox"> 不同路径 II</li><li><input disabled type="checkbox"> 寻找两个正序数组的中位数</li><li><input checked disabled type="checkbox"> 验证回文字符串 Ⅱ</li><li><input disabled type="checkbox"> 旋转字符串</li><li><input checked disabled type="checkbox"> 多数元素</li><li><input checked disabled type="checkbox"> 丑数 III</li><li><input checked disabled type="checkbox"> 数据流中的中位数</li></ul><hr><ul><li><input disabled type="checkbox"> 储水题</li><li><input checked disabled type="checkbox"> 两支不均匀香,测出 15 分钟</li><li><input checked disabled type="checkbox"> LRU</li><li><input checked disabled type="checkbox"> 实现二叉树从上到下的蛇形遍历</li><li><input disabled type="checkbox"> 一个字符串数组，判断数组中的单词是否可以组成字符串</li><li><input disabled type="checkbox"> 现有 5 个抽屉分别装有 1，2，4，1，3 个糖果，小明有三次取糖果的机会，而且每次只能从 相邻的抽屉取，问小明要从哪个抽屉开始取糖果能获取最多糖果?(注:1.题目数据非正式 数据，解题思路:如果用动态规划，如何实现?)</li><li><input disabled type="checkbox"> 某公司有 n 个工区连成一个环形，每个工区一定量的汽油 gas[i]，现有一辆油车装油量不受 限制，油车从 i 工区到 i+1 工区需要消耗汽油量是 consume[i]，gas = [1，3，5，2，3，4]， consume[1，4，2，3，2，3]，问油车从什么工区开始能走完全程?</li><li><input disabled type="checkbox"> 实现 n 个有序链表中取 top k 个元素, 时间复杂度是多少</li><li><input checked disabled type="checkbox"> 求字符串中最大不重复子串</li><li><input checked disabled type="checkbox"> 归并排序</li><li><input disabled type="checkbox"> 隔位置拿抽屉</li><li><input disabled type="checkbox"> 单词搜索</li><li><input checked disabled type="checkbox"> 合并 2 个有序数组</li><li><input disabled type="checkbox"> 合并 n 个有序数组</li><li><input disabled type="checkbox"> 求二叉树的最大路径和</li><li><input disabled type="checkbox"> 求有序数组中比目标值大的下一个 index, eg:数组:{1,3,5,5,5,5,5,6,7,8}，目标值 5;答案为元素 6 的序号:7。</li><li><input disabled type="checkbox"> 递增的数组 array，求距离数组中元素 m 最近(相减最小)的 k 个元素的最大值和最小值 eg array:2,5,8,10,14,17,18,19。m =14，k=4.那么最近的 k 个元素是 10,17,18,19，最小值和最大值为 10,19 </li><li><input disabled type="checkbox"> 多边形的 k 等分点的坐标</li><li><input checked disabled type="checkbox"> 两个数链表求和</li><li><input disabled type="checkbox"> 接雨水</li><li><input disabled type="checkbox"> trie树</li><li><input disabled type="checkbox"> 写代码把中文数字(比如一万零三百二十一)转化成整型数字</li><li><input disabled type="checkbox"> 给无限个范围为 1~m 的数形成一个队列，问最少在前 n 个数的时候，可以通过 加减法计算组合形成 K?(比如说 k=5,给你 2 和 3 可以形成，给你 4 4 3 也可以形成)</li><li><input checked disabled type="checkbox"> 最长不重复子串</li><li><input disabled type="checkbox"> 层次遍历二叉树，每层输出顺序相反</li><li><input disabled type="checkbox"> 二叉树打印出最左列:(二叉树层次遍历的变种)</li><li><input disabled type="checkbox"> 求下列数组的交集 [[1,6], [5,9],[16,30],[8,10]] </li><li><input disabled type="checkbox"> 单链表，基数递增，偶数递减，排序成递增。例子:[1，200，10，180，20，100，100，1]</li><li><input checked disabled type="checkbox"> 股票交易，只能交易一次，求最大收益</li><li><input disabled type="checkbox"> 如何删除链表中的重复节点</li><li><input checked disabled type="checkbox"> 两个数字字符串相乘</li><li><input disabled type="checkbox"> 查找有重复答案的两数之和的索引下标</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 相关知识</title>
      <link href="2019/09/08/Java%20%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>2019/09/08/Java%20%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><a id="more"></a><ul><li><p>重载和重写的区别<br><img src="/images/0361a8849041e3b35189679365559e2f.png" alt="0361a8849041e3b35189679365559e2f.png"></p></li><li><p>String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？</p></li><li><p>自动装箱与拆箱</p><blockquote><p><a href="https://www.jianshu.com/p/bbe6bffcb03b" target="_blank" rel="noopener">https://www.jianshu.com/p/bbe6bffcb03b</a></p></blockquote></li><li><p>== 与 equals</p></li><li><p>final 关键字</p><blockquote><ul><li>修饰类/方法: 不可继承</li><li>修饰变量: 不可重新赋值</li></ul></blockquote></li><li><p>Object类的常见方法</p><blockquote><p>equals, hashcode, clone, finalize(被GC的时候自动调用)</p></blockquote></li><li><p>Java 中的异常处理</p><blockquote><p><a href="http://www.bjpowernode.com/tutorial_baseinterviewquestions/199.html" target="_blank" rel="noopener">http://www.bjpowernode.com/tutorial_baseinterviewquestions/199.html</a></p></blockquote></li><li><p>获取用键盘输入常用的的两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method1</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line">String s  = input.nextLine(); </span><br><span class="line"><span class="comment">// Method 2</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)); </span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure></li><li><p>接口和抽象类的区别是什么</p><blockquote><p><a href="https://blog.csdn.net/qq_34602647/article/details/80560741" target="_blank" rel="noopener">https://blog.csdn.net/qq_34602647/article/details/80560741</a></p></blockquote></li></ul><h2 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2. 集合框架"></a>2. 集合框架</h2><h3 id="2-1-Map"><a href="#2-1-Map" class="headerlink" title="2.1 Map"></a>2.1 Map</h3><h4 id="2-1-1-HashMap"><a href="#2-1-1-HashMap" class="headerlink" title="2.1.1 HashMap"></a>2.1.1 HashMap</h4><ul><li>key可以为null</li><li><a href="https://blog.csdn.net/visant/article/details/80045154" target="_blank" rel="noopener">https://blog.csdn.net/visant/article/details/80045154</a></li><li><a href="https://www.cnblogs.com/constantingF/p/7446307.html" target="_blank" rel="noopener">https://www.cnblogs.com/constantingF/p/7446307.html</a></li><li><a href="https://www.e-learn.cn/content/qita/952273" target="_blank" rel="noopener">https://www.e-learn.cn/content/qita/952273</a></li></ul><h4 id="2-1-2-HashSet"><a href="#2-1-2-HashSet" class="headerlink" title="2.1.2 HashSet"></a>2.1.2 HashSet</h4><ul><li><a href="https://www.cnblogs.com/skillking/p/7250606.html" target="_blank" rel="noopener">https://www.cnblogs.com/skillking/p/7250606.html</a></li></ul><h4 id="2-1-3-LinkedHashMap"><a href="#2-1-3-LinkedHashMap" class="headerlink" title="2.1.3 LinkedHashMap"></a>2.1.3 LinkedHashMap</h4><ul><li><a href="https://www.jianshu.com/p/8f4f58b4b8ab" target="_blank" rel="noopener">https://www.jianshu.com/p/8f4f58b4b8ab</a></li><li><a href="https://www.iteye.com/blog/uule-1522291" target="_blank" rel="noopener">https://www.iteye.com/blog/uule-1522291</a> (图)</li></ul><h4 id="2-1-4-ConcurrentHashMap"><a href="#2-1-4-ConcurrentHashMap" class="headerlink" title="2.1.4 ConcurrentHashMap"></a>2.1.4 ConcurrentHashMap</h4><ul><li>key不能为null</li><li><a href="https://www.cnblogs.com/lijiasnong/p/9963808.html" target="_blank" rel="noopener">https://www.cnblogs.com/lijiasnong/p/9963808.html</a></li><li><a href="https://www.jianshu.com/p/2b3e4b1d49c1" target="_blank" rel="noopener">https://www.jianshu.com/p/2b3e4b1d49c1</a></li></ul><h4 id="2-1-5-HashTable"><a href="#2-1-5-HashTable" class="headerlink" title="2.1.5 HashTable"></a>2.1.5 HashTable</h4><ul><li>HashTable = synchronized HashMap</li><li><a href="https://www.cnblogs.com/owenma/p/8554568.html" target="_blank" rel="noopener">https://www.cnblogs.com/owenma/p/8554568.html</a></li></ul><h4 id="2-1-6-HashMap-的长度为什么是2的幂次方"><a href="#2-1-6-HashMap-的长度为什么是2的幂次方" class="headerlink" title="2.1.6 HashMap 的长度为什么是2的幂次方"></a>2.1.6 HashMap 的长度为什么是2的幂次方</h4><ul><li><a href="https://www.cnblogs.com/wengshuhang/articles/9867176.html" target="_blank" rel="noopener">https://www.cnblogs.com/wengshuhang/articles/9867176.html</a></li></ul><h4 id="2-1-7-HashMap-多线程操作导致死循环问题-HashMap扩容原理"><a href="#2-1-7-HashMap-多线程操作导致死循环问题-HashMap扩容原理" class="headerlink" title="2.1.7 HashMap 多线程操作导致死循环问题(HashMap扩容原理)"></a>2.1.7 HashMap 多线程操作导致死循环问题(HashMap扩容原理)</h4><ul><li><a href="https://blog.csdn.net/zhuqiuhui/article/details/51849692" target="_blank" rel="noopener">https://blog.csdn.net/zhuqiuhui/article/details/51849692</a></li><li><a href="https://segmentfault.com/a/1190000015812438?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015812438?utm_source=tag-newest</a></li><li><a href="https://www.jianshu.com/p/619a8efcf589" target="_blank" rel="noopener">https://www.jianshu.com/p/619a8efcf589</a></li></ul><h4 id="2-1-8-ConcurrentHashMap-和-HashTable的区别"><a href="#2-1-8-ConcurrentHashMap-和-HashTable的区别" class="headerlink" title="2.1.8 ConcurrentHashMap 和 HashTable的区别"></a>2.1.8 ConcurrentHashMap 和 HashTable的区别</h4><ul><li>HashTable是全局锁, ConcurrentHashMap是Segment锁(分段锁)</li></ul><h3 id="2-2-Collection"><a href="#2-2-Collection" class="headerlink" title="2.2 Collection"></a>2.2 Collection</h3><h4 id="2-2-1-Arraylist-与-LinkedList-异同"><a href="#2-2-1-Arraylist-与-LinkedList-异同" class="headerlink" title="2.2.1 Arraylist 与 LinkedList 异同"></a>2.2.1 Arraylist 与 LinkedList 异同</h4><ul><li><a href="https://www.nowcoder.com/questionTerminal/6be89dcb817240248ee25232679c816d?toCommentId=2493133" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6be89dcb817240248ee25232679c816d?toCommentId=2493133</a></li></ul><h4 id="2-2-2-ArrayList-与-Vector-区别"><a href="#2-2-2-ArrayList-与-Vector-区别" class="headerlink" title="2.2.2 ArrayList 与 Vector 区别"></a>2.2.2 ArrayList 与 Vector 区别</h4><ul><li><a href="https://www.cnblogs.com/efforts-will-be-lucky/p/7053666.html" target="_blank" rel="noopener">https://www.cnblogs.com/efforts-will-be-lucky/p/7053666.html</a></li></ul><h3 id="2-3-copyOnWrite"><a href="#2-3-copyOnWrite" class="headerlink" title="2.3 copyOnWrite"></a>2.3 copyOnWrite</h3><h3 id="2-4-Collection和Collections区别"><a href="#2-4-Collection和Collections区别" class="headerlink" title="2.4 Collection和Collections区别"></a>2.4 Collection和Collections区别</h3><ul><li>Collection是集合的接口, Collections是集合工具类</li></ul><h2 id="3-多线程与并发"><a href="#3-多线程与并发" class="headerlink" title="3. 多线程与并发"></a>3. 多线程与并发</h2><h3 id="3-1-ThreadLocal原理-对比-volitile"><a href="#3-1-ThreadLocal原理-对比-volitile" class="headerlink" title="3.1 ThreadLocal原理(对比 volitile)"></a>3.1 ThreadLocal原理(对比 volitile)</h3><ul><li><a href="https://www.jianshu.com/p/0ba78fe61c40" target="_blank" rel="noopener">https://www.jianshu.com/p/0ba78fe61c40</a></li><li><a href="https://www.cnblogs.com/hiver/p/7128024.html" target="_blank" rel="noopener">https://www.cnblogs.com/hiver/p/7128024.html</a></li></ul><h3 id="3-2-什么是上下文切换"><a href="#3-2-什么是上下文切换" class="headerlink" title="3.2 什么是上下文切换"></a>3.2 什么是上下文切换</h3><blockquote><p>CPU通过时间片分配算法来循环执行任务, 当前任务执行一个时间片后会切换到下一个任务. 但是, 在切换前会保存上一个任务的状态, 以便下次切换回这个任务时, 可以再次加载这个任务的状态, 从任务保存到再加载的过程就是一次上下文切换.</p></blockquote><h3 id="3-3-用户态和内核态"><a href="#3-3-用户态和内核态" class="headerlink" title="3.3 用户态和内核态"></a>3.3 用户态和内核态</h3><ul><li><a href="https://www.cnblogs.com/zf-blog/p/9309645.html" target="_blank" rel="noopener">https://www.cnblogs.com/zf-blog/p/9309645.html</a></li></ul><h3 id="3-4-CAS-ABA问题"><a href="#3-4-CAS-ABA问题" class="headerlink" title="3.4 CAS, ABA问题"></a>3.4 CAS, ABA问题</h3><ul><li><a href="https://blog.csdn.net/wufaliang003/article/details/78797203" target="_blank" rel="noopener">https://blog.csdn.net/wufaliang003/article/details/78797203</a></li></ul><h3 id="3-5-各种锁"><a href="#3-5-各种锁" class="headerlink" title="3.5 各种锁"></a>3.5 各种锁</h3><ul><li><a href="https://www.jianshu.com/p/12dadbbfaf08" target="_blank" rel="noopener">可以先看完下面的再回来看这个</a></li></ul><h4 id="3-5-1-自旋-互斥-读写"><a href="#3-5-1-自旋-互斥-读写" class="headerlink" title="3.5.1 自旋, 互斥, 读写"></a>3.5.1 自旋, 互斥, 读写</h4><ul><li><a href="https://www.zhihu.com/question/66733477" target="_blank" rel="noopener">https://www.zhihu.com/question/66733477</a></li><li><a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/81252853</a></li></ul><h4 id="3-5-2-乐观锁-悲观锁"><a href="#3-5-2-乐观锁-悲观锁" class="headerlink" title="3.5.2 乐观锁, 悲观锁"></a>3.5.2 乐观锁, 悲观锁</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484911&amp;idx=1&amp;sn=1d53616437f50b353e33edad6fda2e4f&source=41" target="_blank" rel="noopener">连接太长</a></li></ul><h4 id="3-5-3-CLH-MCS"><a href="#3-5-3-CLH-MCS" class="headerlink" title="3.5.3 CLH, MCS"></a>3.5.3 CLH, MCS</h4><h5 id="3-5-3-1-CLH"><a href="#3-5-3-1-CLH" class="headerlink" title="3.5.3.1 CLH"></a>3.5.3.1 CLH</h5><ul><li><a href="https://www.jianshu.com/p/1b1b44e84394" target="_blank" rel="noopener">https://www.jianshu.com/p/1b1b44e84394</a></li><li><a href="https://www.jianshu.com/p/5ad8539e25c3" target="_blank" rel="noopener">https://www.jianshu.com/p/5ad8539e25c3</a></li><li><a href="http://cmsblogs.com/?p=2188" target="_blank" rel="noopener">http://cmsblogs.com/?p=2188</a></li><li><a href="https://www.cnblogs.com/yuyutianxia/p/4296220.html" target="_blank" rel="noopener">直接看代码</a></li></ul><h6 id="3-5-3-2-MCS"><a href="#3-5-3-2-MCS" class="headerlink" title="3.5.3.2 MCS"></a>3.5.3.2 MCS</h6><ul><li><a href="https://www.jianshu.com/p/1b1b44e84394" target="_blank" rel="noopener">https://www.jianshu.com/p/1b1b44e84394</a></li><li><a href="https://www.cnblogs.com/yuyutianxia/p/4296220.html" target="_blank" rel="noopener">直接看下面解释</a></li></ul><h4 id="3-5-4-可重入锁-不可重入锁"><a href="#3-5-4-可重入锁-不可重入锁" class="headerlink" title="3.5.4 可重入锁, 不可重入锁"></a>3.5.4 可重入锁, 不可重入锁</h4><ul><li><a href="https://blog.csdn.net/u012545728/article/details/80843595" target="_blank" rel="noopener">https://blog.csdn.net/u012545728/article/details/80843595</a></li></ul><h4 id="3-5-5-synchronized"><a href="#3-5-5-synchronized" class="headerlink" title="3.5.5 synchronized"></a>3.5.5 synchronized</h4><h5 id="3-5-5-1-基本概念和使用"><a href="#3-5-5-1-基本概念和使用" class="headerlink" title="3.5.5.1 基本概念和使用"></a>3.5.5.1 基本概念和使用</h5><ul><li><a href="https://blog.csdn.net/xuqiaobo/article/details/51513871" target="_blank" rel="noopener">https://blog.csdn.net/xuqiaobo/article/details/51513871</a></li><li><a href="https://blog.csdn.net/aiyawalie/article/details/53261823" target="_blank" rel="noopener">https://blog.csdn.net/aiyawalie/article/details/53261823</a></li><li>说说 synchronized 关键字和 volatile 关键字的区别</li></ul><h5 id="3-5-5-2-原理-难点"><a href="#3-5-5-2-原理-难点" class="headerlink" title="3.5.5.2 原理(难点)"></a>3.5.5.2 原理(难点)</h5><ul><li><a href="https://www.jianshu.com/p/36eedeb3f912" target="_blank" rel="noopener">https://www.jianshu.com/p/36eedeb3f912</a></li><li><a href="https://www.jianshu.com/p/9998a9db17f7" target="_blank" rel="noopener">https://www.jianshu.com/p/9998a9db17f7</a></li><li><a href="https://www.jianshu.com/p/31b6a0b1b84b" target="_blank" rel="noopener">https://www.jianshu.com/p/31b6a0b1b84b</a></li><li><img src="/images/4491294-e3bcefb2bacea224.png" alt></li></ul><h5 id="3-5-5-3-synchronized和ReentrantLock"><a href="#3-5-5-3-synchronized和ReentrantLock" class="headerlink" title="3.5.5.3 synchronized和ReentrantLock"></a>3.5.5.3 synchronized和ReentrantLock</h5><ul><li><a href="https://baijiahao.baidu.com/s?id=1638104862611986445&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1638104862611986445&amp;wfr=spider&amp;for=pc</a></li><li><a href="https://cloud.tencent.com/developer/article/1414968" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1414968</a></li></ul><h3 id="3-6-AQS实现原理-java并发包的了解"><a href="#3-6-AQS实现原理-java并发包的了解" class="headerlink" title="3.6 AQS实现原理(java并发包的了解)"></a>3.6 AQS实现原理(java并发包的了解)</h3><h4 id="3-6-1-基本"><a href="#3-6-1-基本" class="headerlink" title="3.6.1 基本"></a>3.6.1 基本</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484832&idx=1&sn=f902febd050eac59d67fc0804d7e1ad5&chksm=cea24a6bf9d5c37d6b505fe1d43e4fb709729149f1f77344b4a0f5956cab5020a2e102f2adf2&token=1082669959&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">连接太长</a></li><li><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017372067</a></li><li><a href="https://cloud.tencent.com/developer/article/1447796" target="_blank" rel="noopener">直接看AQS</a></li></ul><h4 id="3-6-2-资源共享方式"><a href="#3-6-2-资源共享方式" class="headerlink" title="3.6.2 资源共享方式"></a>3.6.2 资源共享方式</h4><ul><li><a href="https://www.jianshu.com/p/070191e5beef" target="_blank" rel="noopener">https://www.jianshu.com/p/070191e5beef</a></li></ul><h4 id="3-6-3-模板方法模式-设计模式"><a href="#3-6-3-模板方法模式-设计模式" class="headerlink" title="3.6.3 模板方法模式(设计模式)"></a>3.6.3 模板方法模式(设计模式)</h4><h5 id="3-6-3-1-基本"><a href="#3-6-3-1-基本" class="headerlink" title="3.6.3.1 基本"></a>3.6.3.1 基本</h5><ul><li><a href="https://www.cnblogs.com/wangkaihua/p/9123171.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangkaihua/p/9123171.html</a></li></ul><h5 id="3-6-3-2-应用"><a href="#3-6-3-2-应用" class="headerlink" title="3.6.3.2 应用"></a>3.6.3.2 应用</h5><ul><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li></ul><h3 id="3-7-Atomic"><a href="#3-7-Atomic" class="headerlink" title="3.7 Atomic"></a>3.7 Atomic</h3><h4 id="3-7-1-Atomic原子类-使用"><a href="#3-7-1-Atomic原子类-使用" class="headerlink" title="3.7.1 Atomic原子类, 使用"></a>3.7.1 Atomic原子类, 使用</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484834&amp;idx=1&amp;sn=7d3835091af8125c13fc6db765f4c5bd&source=41#wechat_redirect" target="_blank" rel="noopener">连接太长</a></li><li>四类Atomic: 基本类型, 数组类型, 引用类型, 对象属性修改类型</li></ul><h4 id="3-7-2-原理"><a href="#3-7-2-原理" class="headerlink" title="3.7.2 原理"></a>3.7.2 原理</h4><ul><li><a href="https://blog.csdn.net/huitoukest/article/details/80223453" target="_blank" rel="noopener">https://blog.csdn.net/huitoukest/article/details/80223453</a></li></ul><h3 id="3-8-多线程"><a href="#3-8-多线程" class="headerlink" title="3.8 多线程"></a>3.8 多线程</h3><h4 id="3-8-1-wait方法和sleep方法的区别"><a href="#3-8-1-wait方法和sleep方法的区别" class="headerlink" title="3.8.1 wait方法和sleep方法的区别"></a>3.8.1 wait方法和sleep方法的区别</h4><ul><li><a href="https://blog.csdn.net/qq_42585774/article/details/82935433" target="_blank" rel="noopener">https://blog.csdn.net/qq_42585774/article/details/82935433</a></li></ul><h4 id="3-8-2-Java线程池原理"><a href="#3-8-2-Java线程池原理" class="headerlink" title="3.8.2 Java线程池原理"></a>3.8.2 Java线程池原理</h4><ul><li><a href="https://yq.aliyun.com/articles/687794" target="_blank" rel="noopener">https://yq.aliyun.com/articles/687794</a></li><li><a href="https://blog.51cto.com/14230003/2418026?source=dra" target="_blank" rel="noopener">https://blog.51cto.com/14230003/2418026?source=dra</a></li><li><a href="https://blog.csdn.net/weixin_28760063/article/details/81266152" target="_blank" rel="noopener">https://blog.csdn.net/weixin_28760063/article/details/81266152</a></li><li><a href="https://www.cnblogs.com/a8457013/p/7819044.html" target="_blank" rel="noopener">https://www.cnblogs.com/a8457013/p/7819044.html</a></li></ul><h4 id="3-8-3-设置线程数一般基于哪些考虑"><a href="#3-8-3-设置线程数一般基于哪些考虑" class="headerlink" title="3.8.3 设置线程数一般基于哪些考虑"></a>3.8.3 设置线程数一般基于哪些考虑</h4><ul><li><a href="https://www.jianshu.com/p/1f5195dcc75b" target="_blank" rel="noopener">https://www.jianshu.com/p/1f5195dcc75b</a></li><li><a href="https://www.jianshu.com/p/fbac33d72bd2" target="_blank" rel="noopener">https://www.jianshu.com/p/fbac33d72bd2</a></li><li><a href="https://blog.csdn.net/qrne06/article/details/80587576" target="_blank" rel="noopener">https://blog.csdn.net/qrne06/article/details/80587576</a></li></ul><h4 id="3-8-4-为什么要用线程池"><a href="#3-8-4-为什么要用线程池" class="headerlink" title="3.8.4 为什么要用线程池"></a>3.8.4 为什么要用线程池</h4><ul><li><a href="https://www.cnblogs.com/x-bing/p/5680611.html" target="_blank" rel="noopener">https://www.cnblogs.com/x-bing/p/5680611.html</a></li><li><a href="https://www.jianshu.com/p/174958a72ce9" target="_blank" rel="noopener">https://www.jianshu.com/p/174958a72ce9</a></li></ul><h4 id="3-8-5-如何创建线程池"><a href="#3-8-5-如何创建线程池" class="headerlink" title="3.8.5 如何创建线程池"></a>3.8.5 如何创建线程池</h4><ul><li><a href="https://www.cnblogs.com/gujiande/p/9488462.html" target="_blank" rel="noopener">https://www.cnblogs.com/gujiande/p/9488462.html</a></li><li><a href="https://www.cnblogs.com/fengzheng/p/9297602.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengzheng/p/9297602.html</a></li></ul><h4 id="3-8-6-实现Runnable接口和Callable接口的区别"><a href="#3-8-6-实现Runnable接口和Callable接口的区别" class="headerlink" title="3.8.6 实现Runnable接口和Callable接口的区别"></a>3.8.6 实现Runnable接口和Callable接口的区别</h4><ul><li><a href="https://blog.csdn.net/qq_43045898/article/details/83143106" target="_blank" rel="noopener">https://blog.csdn.net/qq_43045898/article/details/83143106</a></li></ul><h4 id="3-8-7-执行execute-方法和submit-方法的区别是什么呢？"><a href="#3-8-7-执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="3.8.7 执行execute()方法和submit()方法的区别是什么呢？"></a>3.8.7 执行execute()方法和submit()方法的区别是什么呢？</h4><ul><li><a href="https://www.jianshu.com/p/bc054f72cdb0" target="_blank" rel="noopener">https://www.jianshu.com/p/bc054f72cdb0</a></li><li><a href="https://blog.csdn.net/meism5/article/details/90264191" target="_blank" rel="noopener">https://blog.csdn.net/meism5/article/details/90264191</a></li></ul><h4 id="3-8-8-Latch-Barrier-Semaphore使用场景"><a href="#3-8-8-Latch-Barrier-Semaphore使用场景" class="headerlink" title="3.8.8 Latch, Barrier, Semaphore使用场景"></a>3.8.8 Latch, Barrier, Semaphore使用场景</h4><h5 id="3-8-8-1-CountDownLatch"><a href="#3-8-8-1-CountDownLatch" class="headerlink" title="3.8.8.1 CountDownLatch"></a>3.8.8.1 CountDownLatch</h5><ul><li><a href="https://blog.csdn.net/u012637358/article/details/90288585" target="_blank" rel="noopener">https://blog.csdn.net/u012637358/article/details/90288585</a></li><li><a href="https://www.cnblogs.com/fengzheng/p/9153720.html" target="_blank" rel="noopener">代码可以略</a></li></ul><h5 id="3-8-8-2-CyclicBarrier"><a href="#3-8-8-2-CyclicBarrier" class="headerlink" title="3.8.8.2 CyclicBarrier"></a>3.8.8.2 CyclicBarrier</h5><ul><li><a href="https://www.jdon.com/idea/java/Java-cyclicbarrier.html" target="_blank" rel="noopener">代码略</a></li></ul><h5 id="3-8-8-3-Semaphore"><a href="#3-8-8-3-Semaphore" class="headerlink" title="3.8.8.3 Semaphore"></a>3.8.8.3 Semaphore</h5><ul><li><a href="https://segmentfault.com/a/1190000019334692" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019334692</a></li></ul><h4 id="3-8-9-Future-FutureTask-CompletionService的使用-JUC的了解"><a href="#3-8-9-Future-FutureTask-CompletionService的使用-JUC的了解" class="headerlink" title="3.8.9 Future, FutureTask, CompletionService的使用(JUC的了解)"></a>3.8.9 Future, FutureTask, CompletionService的使用(JUC的了解)</h4><h5 id="3-8-9-1-Future-FutureTask"><a href="#3-8-9-1-Future-FutureTask" class="headerlink" title="3.8.9.1 Future, FutureTask"></a>3.8.9.1 Future, FutureTask</h5><ul><li><a href="https://cloud.tencent.com/developer/article/1497827" target="_blank" rel="noopener">代码可以略</a></li><li><a href="https://www.cnblogs.com/xiaoxi/p/8303574.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/8303574.html</a></li></ul><h5 id="3-8-9-2-CompletionService"><a href="#3-8-9-2-CompletionService" class="headerlink" title="3.8.9.2 CompletionService"></a>3.8.9.2 CompletionService</h5><ul><li><a href="https://segmentfault.com/a/1190000019604274?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019604274?utm_source=tag-newest</a></li></ul><h2 id="4-JVM"><a href="#4-JVM" class="headerlink" title="4. JVM"></a>4. JVM</h2><h3 id="4-1-内存结构"><a href="#4-1-内存结构" class="headerlink" title="4.1 内存结构"></a>4.1 内存结构</h3><ul><li><a href="https://juejin.im/post/5c73c6446fb9a04a0d577d14" target="_blank" rel="noopener">https://juejin.im/post/5c73c6446fb9a04a0d577d14</a></li><li><a href="https://zhuanlan.zhihu.com/p/38348646" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38348646</a><blockquote><p>int和Integer有什么区别, 分别存储在哪里</p></blockquote></li></ul><h3 id="4-2-GC"><a href="#4-2-GC" class="headerlink" title="4.2 GC"></a>4.2 GC</h3><ul><li><a href="https://juejin.im/post/5a15be736fb9a044fc4464d6#heading-12" target="_blank" rel="noopener">https://juejin.im/post/5a15be736fb9a044fc4464d6#heading-12</a></li><li><a href="https://www.infoq.cn/article/ZOYqRI4c-BFKmUBmzmKN" target="_blank" rel="noopener">https://www.infoq.cn/article/ZOYqRI4c-BFKmUBmzmKN</a></li><li><a href="https://www.infoq.cn/article/3WyReTKqrHIvtw4frmr3" target="_blank" rel="noopener">https://www.infoq.cn/article/3WyReTKqrHIvtw4frmr3</a></li><li><a href="https://www.jianshu.com/p/108ddab3ad3f" target="_blank" rel="noopener">判断一个Java对象是否存活</a></li><li><a href="https://juejin.im/post/5c9ccaff6fb9a070fe0ded51" target="_blank" rel="noopener">内存泄露(图略)</a></li><li><a href="https://www.jianshu.com/p/d903fd25f30a" target="_blank" rel="noopener">CMS/G1</a></li><li><a href="https://zhuanlan.zhihu.com/p/54048685" target="_blank" rel="noopener">G1</a></li></ul><h3 id="4-3-ClassLoader"><a href="#4-3-ClassLoader" class="headerlink" title="4.3 ClassLoader"></a>4.3 ClassLoader</h3><ul><li><a href="https://www.jianshu.com/p/51b2c50c58eb" target="_blank" rel="noopener">代码略</a></li><li><a href="https://www.cnblogs.com/Qian123/p/5707562.html" target="_blank" rel="noopener">代码略</a></li><li><a href="https://www.jianshu.com/p/0ddf610991a5" target="_blank" rel="noopener">class文件结构解析</a></li><li><a href="https://segmentfault.com/a/1190000016011932" target="_blank" rel="noopener">class文件结构解析2</a></li></ul><h3 id="4-4-new-一个对象的过程中发生了什么"><a href="#4-4-new-一个对象的过程中发生了什么" class="headerlink" title="4.4 new 一个对象的过程中发生了什么"></a>4.4 new 一个对象的过程中发生了什么</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/85377745" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85377745</a></li></ul><h3 id="4-5-调优"><a href="#4-5-调优" class="headerlink" title="4.5 调优"></a>4.5 调优</h3><ul><li>常用的性能优化方式有哪些</li><li>常用的启动参数以及其作用</li></ul><h3 id="4-6-JIT"><a href="#4-6-JIT" class="headerlink" title="4.6 JIT"></a>4.6 JIT</h3><ul><li><a href="https://www.jianshu.com/p/f907fb7c88e9" target="_blank" rel="noopener">https://www.jianshu.com/p/f907fb7c88e9</a></li><li><a href="https://juejin.im/post/5b3782b1e51d4558dc4ae4a7" target="_blank" rel="noopener">https://juejin.im/post/5b3782b1e51d4558dc4ae4a7</a></li></ul><h2 id="5-Spring"><a href="#5-Spring" class="headerlink" title="5. Spring"></a>5. Spring</h2><h3 id="5-1-基本"><a href="#5-1-基本" class="headerlink" title="5.1 基本"></a>5.1 基本</h3><h4 id="5-1-1-Bean作用域"><a href="#5-1-1-Bean作用域" class="headerlink" title="5.1.1 Bean作用域"></a>5.1.1 Bean作用域</h4><ul><li><a href="https://blog.csdn.net/fuzhongmin05/article/details/73389779" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/73389779</a></li></ul><h4 id="5-1-2-IOC"><a href="#5-1-2-IOC" class="headerlink" title="5.1.2 IOC"></a>5.1.2 IOC</h4><ul><li><a href="https://www.cnblogs.com/chenssy/p/9576769.html" target="_blank" rel="noopener">只看上面第一节的理论即可</a></li><li><a href="https://www.jianshu.com/p/17b66e6390fd" target="_blank" rel="noopener">https://www.jianshu.com/p/17b66e6390fd</a></li><li><a href="https://www.jianshu.com/p/2808f7c4a24f" target="_blank" rel="noopener">https://www.jianshu.com/p/2808f7c4a24f</a></li><li>BeanFactory是根基, ApplicationContext提供更高级的用法和属性(面向实际使用的开发者)</li><li><a href="https://segmentfault.com/a/1190000018077152?utm_source=tag-newest" target="_blank" rel="noopener">Autowired</a></li></ul><h4 id="5-1-3-AOP"><a href="#5-1-3-AOP" class="headerlink" title="5.1.3 AOP"></a>5.1.3 AOP</h4><h5 id="5-1-3-1-基本"><a href="#5-1-3-1-基本" class="headerlink" title="5.1.3.1 基本"></a>5.1.3.1 基本</h5><ul><li><a href="https://segmentfault.com/a/1190000015018888?utm_source=tag-newest#articleHeader2" target="_blank" rel="noopener">只看1.1, 1.2</a></li></ul><h5 id="5-1-3-2-代理模式"><a href="#5-1-3-2-代理模式" class="headerlink" title="5.1.3.2 代理模式"></a>5.1.3.2 代理模式</h5><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1#rd" target="_blank" rel="noopener">连接太长</a></li><li><a href="https://www.jianshu.com/p/9b489bb6abb0" target="_blank" rel="noopener">代码不用看</a></li></ul><h5 id="5-1-3-3-应用场景"><a href="#5-1-3-3-应用场景" class="headerlink" title="5.1.3.3 应用场景"></a>5.1.3.3 应用场景</h5><ul><li><a href="https://www.jianshu.com/p/0799aa19ada1" target="_blank" rel="noopener">看第二节应用场景即可</a></li></ul><h4 id="5-1-4-请求过程"><a href="#5-1-4-请求过程" class="headerlink" title="5.1.4 请求过程"></a>5.1.4 请求过程</h4><h5 id="5-1-4-1-Servlet生命周期"><a href="#5-1-4-1-Servlet生命周期" class="headerlink" title="5.1.4.1 Servlet生命周期"></a>5.1.4.1 Servlet生命周期</h5><ul><li><img src="/images/aa9ab00d1ff5f54f0f22f8f4d959bf3bcf2.jpg" alt></li></ul><h5 id="5-1-4-2-过程"><a href="#5-1-4-2-过程" class="headerlink" title="5.1.4.2 过程"></a>5.1.4.2 过程</h5><ul><li><a href="https://www.cnblogs.com/leskang/p/6101368.html" target="_blank" rel="noopener">https://www.cnblogs.com/leskang/p/6101368.html</a></li></ul><h3 id="5-2-相关应用"><a href="#5-2-相关应用" class="headerlink" title="5.2 相关应用"></a>5.2 相关应用</h3><h4 id="5-2-1-Mybatis"><a href="#5-2-1-Mybatis" class="headerlink" title="5.2.1 Mybatis"></a>5.2.1 Mybatis</h4><ul><li><a href="https://blog.csdn.net/u014745069/article/details/80788127" target="_blank" rel="noopener">Mybatis工作流程</a></li><li><a href="https://blog.csdn.net/a6jishuren/article/details/79656778" target="_blank" rel="noopener">Mybatis框架传递参数方式</a></li></ul><h4 id="5-2-2-事务"><a href="#5-2-2-事务" class="headerlink" title="5.2.2 事务"></a>5.2.2 事务</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/76150369" target="_blank" rel="noopener">我是如何在面试别人Spring事务时“套路”对方的</a></li><li>Spring 事务中的隔离级别<ul><li><a href="https://www.liangzl.com/get-article-detail-16242.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-16242.html</a></li><li><a href="http://www.sohu.com/a/245773215_100012573" target="_blank" rel="noopener">http://www.sohu.com/a/245773215_100012573</a></li></ul></li><li><a href="https://blog.csdn.net/u010963948/article/details/82761383" target="_blank" rel="noopener">Spring 事务中的事务传播行为</a></li></ul><h3 id="5-3-设计模式"><a href="#5-3-设计模式" class="headerlink" title="5.3 设计模式"></a>5.3 设计模式</h3><ul><li>常用的设计模式, 应用的例子(23种设计模式)<ul><li>常用设计模式(前5个最常用): 单例, 工厂, 建造者, 代理, 模板方法(AQS), 适配器, 装饰器, 观察者, 策略, 备忘录</li><li><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">http://c.biancheng.net/design_pattern/</a></li><li><a href="http://www.cocoachina.com/articles/31808" target="_blank" rel="noopener">http://www.cocoachina.com/articles/31808</a></li></ul></li><li><a href="http://hukai.me/java-notes-singleton-pattern/" target="_blank" rel="noopener">单例模式的几种写法, 优缺点</a></li><li><a href="https://www.jianshu.com/p/c06a686dae39" target="_blank" rel="noopener">装饰器模式和代理模式的区别 (理解较复杂)</a></li><li>JDK或Spring中用的设计模式举例(对一些开源源码的了解)<blockquote><ul><li>JDK: <a href="https://blog.csdn.net/ZixiangLi/article/details/85237318" target="_blank" rel="noopener">https://blog.csdn.net/ZixiangLi/article/details/85237318</a></li><li>Spring: <a href="https://www.jianshu.com/p/c4f367107182" target="_blank" rel="noopener">https://www.jianshu.com/p/c4f367107182</a> (<code>8/9</code>不用看)</li></ul></blockquote></li></ul><h3 id="5-4-Spring生态"><a href="#5-4-Spring生态" class="headerlink" title="5.4 Spring生态"></a>5.4 Spring生态</h3><ul><li><a href="https://blog.csdn.net/wd2014610/article/details/79651494" target="_blank" rel="noopener">https://blog.csdn.net/wd2014610/article/details/79651494</a></li></ul><h2 id="6-树-堆"><a href="#6-树-堆" class="headerlink" title="6. 树, 堆"></a>6. 树, 堆</h2><h3 id="6-1-树"><a href="#6-1-树" class="headerlink" title="6.1 树"></a>6.1 树</h3><ul><li><a href="https://www.jianshu.com/p/6f573afd2501" target="_blank" rel="noopener">https://www.jianshu.com/p/6f573afd2501</a></li><li><a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27700617</a></li><li><a href="https://www.cnblogs.com/maybe2030/p/4732377.html" target="_blank" rel="noopener">代码略</a></li><li><a href="https://zhuanlan.zhihu.com/p/79980618" target="_blank" rel="noopener">图解红黑树</a></li></ul><h3 id="6-2-堆"><a href="#6-2-堆" class="headerlink" title="6.2 堆"></a>6.2 堆</h3><ul><li><a href="https://www.jianshu.com/p/6b526aa481b1" target="_blank" rel="noopener">https://www.jianshu.com/p/6b526aa481b1</a></li><li><a href="https://juejin.im/post/59fc75f76fb9a0452206dd15" target="_blank" rel="noopener">https://juejin.im/post/59fc75f76fb9a0452206dd15</a></li></ul><h2 id="7-MySQL"><a href="#7-MySQL" class="headerlink" title="7. MySQL"></a>7. MySQL</h2><h3 id="7-1-ACID原则是什么-隔离级别包含哪些-基础"><a href="#7-1-ACID原则是什么-隔离级别包含哪些-基础" class="headerlink" title="7.1 ACID原则是什么, 隔离级别包含哪些(基础)"></a>7.1 ACID原则是什么, 隔离级别包含哪些(基础)</h3><ul><li><a href="https://blog.csdn.net/tree_ifconfig/article/details/81326892" target="_blank" rel="noopener">https://blog.csdn.net/tree_ifconfig/article/details/81326892</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848</a></li><li><a href="http://www.zsythink.net/archives/1233/" target="_blank" rel="noopener">http://www.zsythink.net/archives/1233/</a></li></ul><h3 id="7-2-MyIsam和InnoDB的各种区别-数据库引擎相关"><a href="#7-2-MyIsam和InnoDB的各种区别-数据库引擎相关" class="headerlink" title="7.2 MyIsam和InnoDB的各种区别(数据库引擎相关)"></a>7.2 MyIsam和InnoDB的各种区别(数据库引擎相关)</h3><ul><li><a href="https://www.jb51.net/article/62457.htm" target="_blank" rel="noopener">https://www.jb51.net/article/62457.htm</a></li></ul><h3 id="7-3-索引的底层数据结构-联合索引的生效规则-索引相关"><a href="#7-3-索引的底层数据结构-联合索引的生效规则-索引相关" class="headerlink" title="7.3 索引的底层数据结构, 联合索引的生效规则(索引相关)"></a>7.3 索引的底层数据结构, 联合索引的生效规则(索引相关)</h3><ul><li><a href="https://blog.csdn.net/caijunsen/article/details/83045985" target="_blank" rel="noopener">https://blog.csdn.net/caijunsen/article/details/83045985</a></li></ul><h3 id="7-4-sql查询优化实践经验-explain-profile的使用-sql调优经验"><a href="#7-4-sql查询优化实践经验-explain-profile的使用-sql调优经验" class="headerlink" title="7.4 sql查询优化实践经验, explain, profile的使用(sql调优经验)"></a>7.4 sql查询优化实践经验, explain, profile的使用(sql调优经验)</h3><ul><li><a href="https://www.cnblogs.com/binbinyouni/p/6070715.html" target="_blank" rel="noopener">https://www.cnblogs.com/binbinyouni/p/6070715.html</a></li><li><a href="https://www.cnblogs.com/clphp/p/5403215.html" target="_blank" rel="noopener">https://www.cnblogs.com/clphp/p/5403215.html</a></li><li><a href="https://www.jianshu.com/p/2de16472722e" target="_blank" rel="noopener">https://www.jianshu.com/p/2de16472722e</a></li></ul><h3 id="7-5-分库分表相关的了解"><a href="#7-5-分库分表相关的了解" class="headerlink" title="7.5 分库分表相关的了解"></a>7.5 分库分表相关的了解</h3><ul><li><a href="https://www.jianshu.com/p/f093ff9ace4b" target="_blank" rel="noopener">https://www.jianshu.com/p/f093ff9ace4b</a></li></ul><h3 id="7-6-A、B两表-找出ID字段中-存在A表-但是不存在B表的数据"><a href="#7-6-A、B两表-找出ID字段中-存在A表-但是不存在B表的数据" class="headerlink" title="7.6 A、B两表, 找出ID字段中, 存在A表, 但是不存在B表的数据"></a>7.6 A、B两表, 找出ID字段中, 存在A表, 但是不存在B表的数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A a <span class="keyword">left</span> <span class="keyword">join</span> B b <span class="keyword">on</span> a.id = b.id <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A a <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">num</span> <span class="keyword">from</span> B b <span class="keyword">where</span> a.id = b.id) = <span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A a <span class="keyword">where</span> a.id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> b.id <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure><h3 id="7-7-为什么索引能提高查询速度"><a href="#7-7-为什么索引能提高查询速度" class="headerlink" title="7.7 为什么索引能提高查询速度?"></a>7.7 为什么索引能提高查询速度?</h3><ul><li>查询时会先去索引列表中一次定位到特定值的行数, 减少遍历匹配的行数</li></ul><h3 id="7-8-Mysql如何为表字段添加索引？"><a href="#7-8-Mysql如何为表字段添加索引？" class="headerlink" title="7.8 Mysql如何为表字段添加索引？"></a>7.8 Mysql如何为表字段添加索引？</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`xxx`</span> <span class="keyword">add</span> <span class="keyword">index</span> <span class="string">`idx_name`</span> (<span class="string">`col1`</span>, <span class="string">`col2`</span>)</span><br></pre></td></tr></table></figure><h3 id="7-9-大表的常见优化手段"><a href="#7-9-大表的常见优化手段" class="headerlink" title="7.9 大表的常见优化手段"></a>7.9 大表的常见优化手段</h3><ul><li><a href="https://www.cnblogs.com/wyy123/p/6027097.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyy123/p/6027097.html</a></li></ul><h2 id="8-网络编程与操作系统"><a href="#8-网络编程与操作系统" class="headerlink" title="8. 网络编程与操作系统"></a>8. 网络编程与操作系统</h2><h3 id="8-1-网络协议"><a href="#8-1-网络协议" class="headerlink" title="8.1 网络协议"></a>8.1 网络协议</h3><h4 id="8-1-1-TCP-UDP"><a href="#8-1-1-TCP-UDP" class="headerlink" title="8.1.1 TCP, UDP"></a>8.1.1 TCP, UDP</h4><ul><li>TCP: 面向连接协议</li><li>UDP: 无连接协议</li><li>链接1: <a href="https://www.cnblogs.com/bokeyuanlongbin/p/9072399.html" target="_blank" rel="noopener">https://www.cnblogs.com/bokeyuanlongbin/p/9072399.html</a> (先看9, 再看10, 然后看其他所有)</li><li>连接2: <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484889&idx=1&sn=5f9e6f5c29f9514701c246573d15d9fa&chksm=cea24a12f9d5c3041efd5cf864eb69b76aea6ef9c000a72b16d54794aab97d4fb53515a77147&token=1082669959&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">连接太长</a></li><li><a href="https://blog.csdn.net/qq_41431406/article/details/97926927" target="_blank" rel="noopener">TCP 拥塞控制</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484889&idx=1&sn=5f9e6f5c29f9514701c246573d15d9fa&chksm=cea24a12f9d5c3041efd5cf864eb69b76aea6ef9c000a72b16d54794aab97d4fb53515a77147&token=1082669959&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">连接太长</a></li></ul><h4 id="8-1-2-TCP的三次握手-四次挥手"><a href="#8-1-2-TCP的三次握手-四次挥手" class="headerlink" title="8.1.2 TCP的三次握手, 四次挥手"></a>8.1.2 TCP的三次握手, 四次挥手</h4><ul><li>链接1: 3</li><li><img src="/images/7896890-895124472bd4317b.png" alt></li></ul><h4 id="8-1-3-HTTP-HTTPS"><a href="#8-1-3-HTTP-HTTPS" class="headerlink" title="8.1.3 HTTP, HTTPS"></a>8.1.3 HTTP, HTTPS</h4><h5 id="8-1-3-1-HTTP"><a href="#8-1-3-1-HTTP" class="headerlink" title="8.1.3.1 HTTP"></a>8.1.3.1 HTTP</h5><ul><li><img src="/images/20180719094756330.jpeg" alt></li><li><img src="/images/20180723105652242.jpeg" alt></li></ul><h5 id="8-1-3-2-RSA加密"><a href="#8-1-3-2-RSA加密" class="headerlink" title="8.1.3.2 RSA加密"></a>8.1.3.2 RSA加密</h5><ul><li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a></li></ul><h5 id="8-1-3-3-HTTPS"><a href="#8-1-3-3-HTTPS" class="headerlink" title="8.1.3.3 HTTPS"></a>8.1.3.3 HTTPS</h5><ul><li><a href="https://www.jianshu.com/p/27862635c077" target="_blank" rel="noopener">https://www.jianshu.com/p/27862635c077</a></li></ul><h4 id="8-1-4-长连接-短连接"><a href="#8-1-4-长连接-短连接" class="headerlink" title="8.1.4 长连接, 短连接"></a>8.1.4 长连接, 短连接</h4><ul><li>此连接指的是TCP连接</li><li>HTTP会话永远都是: 请求响应结束, 长连接指一次TCP连接可以传递多次的HTTP报文信息</li><li>声明长连接: 客户端和服务端在header中都带上 Connection: keep-alive</li><li><a href="https://segmentfault.com/a/1190000015821798" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015821798</a></li></ul><h4 id="8-1-5-在浏览器中输入url地址到显示主页的过程"><a href="#8-1-5-在浏览器中输入url地址到显示主页的过程" class="headerlink" title="8.1.5 在浏览器中输入url地址到显示主页的过程"></a>8.1.5 在浏览器中输入url地址到显示主页的过程</h4><ul><li><img src="/images/1184092-20181009213048506-959422609.png" alt></li><li><a href="https://zhuanlan.zhihu.com/p/82956784" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82956784</a></li></ul><h4 id="8-1-6-IO-NIO"><a href="#8-1-6-IO-NIO" class="headerlink" title="8.1.6 IO/NIO"></a>8.1.6 IO/NIO</h4><ul><li><a href="https://blog.csdn.net/u013956074/article/details/80974190" target="_blank" rel="noopener">https://blog.csdn.net/u013956074/article/details/80974190</a></li><li><a href="https://www.cnblogs.com/aspirant/p/8630283.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8630283.html</a></li></ul><h4 id="8-1-7-零拷贝"><a href="#8-1-7-零拷贝" class="headerlink" title="8.1.7 零拷贝"></a>8.1.7 零拷贝</h4><ul><li><a href="https://mp.weixin.qq.com/s/oPv1-wrhYjiOC1o0M0tjMA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oPv1-wrhYjiOC1o0M0tjMA</a></li><li><a href="https://my.oschina.net/u/3990817/blog/3045359" target="_blank" rel="noopener">https://my.oschina.net/u/3990817/blog/3045359</a></li><li><a href="https://zhuanlan.zhihu.com/p/88789697" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88789697</a></li><li>文件传输<ul><li>传输大文件的时候, 使用「异步 I/O + 直接 I/O」</li><li>传输小文件的时候, 则使用「零拷贝技术」</li></ul></li></ul><h3 id="8-2-操作系统"><a href="#8-2-操作系统" class="headerlink" title="8.2 操作系统"></a>8.2 操作系统</h3><h4 id="8-2-1-基本概念"><a href="#8-2-1-基本概念" class="headerlink" title="8.2.1 基本概念"></a>8.2.1 基本概念</h4><ul><li>进程: 对于操作系统来说, 一个任务就是一个进程, 系统资源分配和调度运行的基本单位</li><li>线程: 单个进程中执行中每个任务就是一个线程, 是进程中执行运算的最小单位</li><li>用户态和内核态: <a href="https://www.jianshu.com/p/38ea929e1668" target="_blank" rel="noopener">https://www.jianshu.com/p/38ea929e1668</a></li></ul><h4 id="8-2-2-算法"><a href="#8-2-2-算法" class="headerlink" title="8.2.2 算法"></a>8.2.2 算法</h4><h5 id="8-2-2-1-磁盘调度-电梯调度"><a href="#8-2-2-1-磁盘调度-电梯调度" class="headerlink" title="8.2.2.1 磁盘调度/电梯调度"></a>8.2.2.1 磁盘调度/电梯调度</h5><ul><li><a href="https://blog.csdn.net/qq_27607965/article/details/82355797" target="_blank" rel="noopener">https://blog.csdn.net/qq_27607965/article/details/82355797</a></li><li><a href="https://blog.51cto.com/acevi/2096277" target="_blank" rel="noopener">https://blog.51cto.com/acevi/2096277</a> (代码)</li></ul><h5 id="8-2-2-2-缓存淘汰算法-LRU-LFU-FIFO"><a href="#8-2-2-2-缓存淘汰算法-LRU-LFU-FIFO" class="headerlink" title="8.2.2.2 缓存淘汰算法: LRU, LFU, FIFO"></a>8.2.2.2 缓存淘汰算法: LRU, LFU, FIFO</h5><ul><li><a href="https://www.jianshu.com/p/908e4b671de0" target="_blank" rel="noopener">https://www.jianshu.com/p/908e4b671de0</a></li></ul><h4 id="8-2-3-信号量-互斥锁-不好理解"><a href="#8-2-3-信号量-互斥锁-不好理解" class="headerlink" title="8.2.3 信号量, 互斥锁 (不好理解)"></a>8.2.3 信号量, 互斥锁 (不好理解)</h4><ul><li><a href="https://www.jianshu.com/p/c6ba8bcc22bc" target="_blank" rel="noopener">https://www.jianshu.com/p/c6ba8bcc22bc</a></li><li><a href="https://www.nowcoder.com/questionTerminal/c97a743b7ed04995b9810cb6676b22ce?toCommentId=1540700" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c97a743b7ed04995b9810cb6676b22ce?toCommentId=1540700</a></li></ul><h4 id="8-2-4-Linux"><a href="#8-2-4-Linux" class="headerlink" title="8.2.4 Linux"></a>8.2.4 Linux</h4><h5 id="8-2-4-1-文件系统"><a href="#8-2-4-1-文件系统" class="headerlink" title="8.2.4.1 文件系统"></a>8.2.4.1 文件系统</h5><ul><li><a href="https://blog.csdn.net/qq_16777851/article/details/82914484" target="_blank" rel="noopener">https://blog.csdn.net/qq_16777851/article/details/82914484</a></li></ul><h5 id="8-2-4-2-常见的-Linux-命令"><a href="#8-2-4-2-常见的-Linux-命令" class="headerlink" title="8.2.4.2 常见的 Linux 命令"></a>8.2.4.2 常见的 Linux 命令</h5><ul><li>cd ls mkdir rm cat tail grep history</li></ul><h4 id="8-2-5-进程间通讯的方式有哪些"><a href="#8-2-5-进程间通讯的方式有哪些" class="headerlink" title="8.2.5 进程间通讯的方式有哪些"></a>8.2.5 进程间通讯的方式有哪些</h4><ul><li><a href="https://www.jianshu.com/p/8e4f9978e5b8" target="_blank" rel="noopener">https://www.jianshu.com/p/8e4f9978e5b8</a></li></ul><h2 id="9-分布式"><a href="#9-分布式" class="headerlink" title="9. 分布式"></a>9. 分布式</h2><h3 id="9-1-Redis"><a href="#9-1-Redis" class="headerlink" title="9.1 Redis"></a>9.1 Redis</h3><h4 id="9-1-1-为什么要用-redis缓存"><a href="#9-1-1-为什么要用-redis缓存" class="headerlink" title="9.1.1 为什么要用 redis缓存"></a>9.1.1 为什么要用 redis缓存</h4><ul><li><a href="https://www.cnblogs.com/bigben0123/p/9115597.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigben0123/p/9115597.html</a></li></ul><h4 id="9-1-2-为什么要用-redis-而不用-map-guava-做缓存"><a href="#9-1-2-为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="9.1.2 为什么要用 redis 而不用 map/guava 做缓存?"></a>9.1.2 为什么要用 redis 而不用 map/guava 做缓存?</h4><ul><li><a href="https://www.jianshu.com/p/9d855cddb274?utm_source=oschina-app" target="_blank" rel="noopener">https://www.jianshu.com/p/9d855cddb274?utm_source=oschina-app</a></li></ul><h4 id="9-1-3-redis-和-memcached-的区别"><a href="#9-1-3-redis-和-memcached-的区别" class="headerlink" title="9.1.3 redis 和 memcached 的区别"></a>9.1.3 redis 和 memcached 的区别</h4><ul><li><a href="https://www.cnblogs.com/xingxia/p/redis_compare_memcache.html" target="_blank" rel="noopener">直接看最下面的区别就行了</a></li></ul><h4 id="9-1-4-常见数据结构"><a href="#9-1-4-常见数据结构" class="headerlink" title="9.1.4 常见数据结构"></a>9.1.4 常见数据结构</h4><ul><li>string</li><li>list: 双向链表</li><li>hash: Java中的HashMap</li><li>set: Java中的HashSet</li><li>zset: 带权重的set</li><li><a href="https://linux.cn/article-9879-1.html" target="_blank" rel="noopener">Streams(新)</a></li><li><a href="https://blog.csdn.net/shengqianfeng/article/details/82684354" target="_blank" rel="noopener">https://blog.csdn.net/shengqianfeng/article/details/82684354</a></li><li><a href="https://www.cnblogs.com/alunchen/p/9836170.html" target="_blank" rel="noopener">使用场景</a></li></ul><h4 id="9-1-5-过期时间-内存淘汰机制-内容不多"><a href="#9-1-5-过期时间-内存淘汰机制-内容不多" class="headerlink" title="9.1.5 过期时间, 内存淘汰机制 (内容不多)"></a>9.1.5 过期时间, 内存淘汰机制 (内容不多)</h4><ul><li><a href="https://blog.csdn.net/jiangchunhui2009/article/details/81504073" target="_blank" rel="noopener">直接看5</a></li><li><a href="https://www.cnblogs.com/xiaohaigui/p/10976084.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohaigui/p/10976084.html</a></li><li><a href="https://www.jianshu.com/p/ad8f35c2c0d0" target="_blank" rel="noopener">https://www.jianshu.com/p/ad8f35c2c0d0</a></li></ul><h4 id="9-1-6-持久化机制"><a href="#9-1-6-持久化机制" class="headerlink" title="9.1.6 持久化机制"></a>9.1.6 持久化机制</h4><blockquote><p>怎么保证 redis 挂掉之后再重启数据可以进行恢复</p><ul><li><a href="https://www.liangzl.com/get-article-detail-126557.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-126557.html</a></li></ul></blockquote><h4 id="9-1-7-事务"><a href="#9-1-7-事务" class="headerlink" title="9.1.7 事务"></a>9.1.7 事务</h4><ul><li><a href="https://www.cnblogs.com/DeepInThought/p/10720132.html" target="_blank" rel="noopener">https://www.cnblogs.com/DeepInThought/p/10720132.html</a></li></ul><h4 id="9-1-8-缓存雪崩-缓存穿透"><a href="#9-1-8-缓存雪崩-缓存穿透" class="headerlink" title="9.1.8 缓存雪崩, 缓存穿透"></a>9.1.8 缓存雪崩, 缓存穿透</h4><ul><li><a href="https://www.cnblogs.com/raichen/p/7750165.html" target="_blank" rel="noopener">https://www.cnblogs.com/raichen/p/7750165.html</a></li></ul><h4 id="9-1-9-并发竞争-Key-问题"><a href="#9-1-9-并发竞争-Key-问题" class="headerlink" title="9.1.9 并发竞争 Key 问题"></a>9.1.9 并发竞争 Key 问题</h4><ul><li><a href="https://blog.csdn.net/qq_42253147/article/details/94446727" target="_blank" rel="noopener">https://blog.csdn.net/qq_42253147/article/details/94446727</a></li></ul><h4 id="9-1-10-如何保证缓存与数据库双写时的数据一致性"><a href="#9-1-10-如何保证缓存与数据库双写时的数据一致性" class="headerlink" title="9.1.10 如何保证缓存与数据库双写时的数据一致性"></a>9.1.10 如何保证缓存与数据库双写时的数据一致性</h4><ul><li><a href="https://blog.csdn.net/chang384915878/article/details/86756463" target="_blank" rel="noopener">https://blog.csdn.net/chang384915878/article/details/86756463</a></li><li><a href="https://www.jianshu.com/p/a9bbcd3ec1e5" target="_blank" rel="noopener">https://www.jianshu.com/p/a9bbcd3ec1e5</a></li></ul><h4 id="9-1-11-分布式锁"><a href="#9-1-11-分布式锁" class="headerlink" title="9.1.11 分布式锁"></a>9.1.11 分布式锁</h4><ul><li><a href="https://cloud.tencent.com/developer/news/241627" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/241627</a></li></ul><h3 id="9-2-消息队列"><a href="#9-2-消息队列" class="headerlink" title="9.2 消息队列"></a>9.2 消息队列</h3><h4 id="9-2-1-什么是消息队列？为什么要用消息队列？"><a href="#9-2-1-什么是消息队列？为什么要用消息队列？" class="headerlink" title="9.2.1  什么是消息队列？为什么要用消息队列？"></a>9.2.1  什么是消息队列？为什么要用消息队列？</h4><ul><li><a href="https://blog.csdn.net/fengqiangdu/article/details/96114997" target="_blank" rel="noopener">https://blog.csdn.net/fengqiangdu/article/details/96114997</a></li></ul><h4 id="9-2-1-使用消息队列带来的一些问题"><a href="#9-2-1-使用消息队列带来的一些问题" class="headerlink" title="9.2.1 使用消息队列带来的一些问题"></a>9.2.1 使用消息队列带来的一些问题</h4><ul><li><a href="https://www.jianshu.com/p/f40cd4d6737e" target="_blank" rel="noopener">https://www.jianshu.com/p/f40cd4d6737e</a></li></ul><h4 id="9-2-3-常见消息队列"><a href="#9-2-3-常见消息队列" class="headerlink" title="9.2.3 常见消息队列"></a>9.2.3 常见消息队列</h4><h5 id="9-2-3-1-RabbitMQ"><a href="#9-2-3-1-RabbitMQ" class="headerlink" title="9.2.3.1 RabbitMQ"></a>9.2.3.1 RabbitMQ</h5><ul><li><a href="https://blog.csdn.net/qq_42629110/article/details/84965084" target="_blank" rel="noopener">https://blog.csdn.net/qq_42629110/article/details/84965084</a></li></ul><h5 id="9-2-3-2-常见消息队列对比"><a href="#9-2-3-2-常见消息队列对比" class="headerlink" title="9.2.3.2 常见消息队列对比"></a>9.2.3.2 常见消息队列对比</h5><ul><li><a href="https://blog.csdn.net/myhes/article/details/83247108" target="_blank" rel="noopener">https://blog.csdn.net/myhes/article/details/83247108</a></li><li><a href="https://www.cnblogs.com/xifengxiaoma/p/9391647.html" target="_blank" rel="noopener">https://www.cnblogs.com/xifengxiaoma/p/9391647.html</a></li></ul><h4 id="9-2-4-JMS"><a href="#9-2-4-JMS" class="headerlink" title="9.2.4 JMS"></a>9.2.4 JMS</h4><h5 id="9-2-4-1-基本"><a href="#9-2-4-1-基本" class="headerlink" title="9.2.4.1 基本"></a>9.2.4.1 基本</h5><ul><li>JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。而MQ则是消息队列服务，是面向消息中间件（MOM）的最终实现，是真正的服务提供者；MQ的实现可以基于JMS，也可以基于其他规范或标准。</li><li><a href="https://www.cnblogs.com/molao-doing/articles/6557305.html" target="_blank" rel="noopener">https://www.cnblogs.com/molao-doing/articles/6557305.html</a></li><li><a href="https://www.cnblogs.com/Zender/p/9098410.html" target="_blank" rel="noopener">看到2.4即可</a></li></ul><h5 id="9-2-4-2-JMS两种消息模型"><a href="#9-2-4-2-JMS两种消息模型" class="headerlink" title="9.2.4.2 JMS两种消息模型"></a>9.2.4.2 JMS两种消息模型</h5><ul><li><a href="https://www.cnblogs.com/mfmdaoyou/p/6740818.html" target="_blank" rel="noopener">https://www.cnblogs.com/mfmdaoyou/p/6740818.html</a></li></ul><h5 id="9-2-4-3-JMS五种消息类型"><a href="#9-2-4-3-JMS五种消息类型" class="headerlink" title="9.2.4.3 JMS五种消息类型"></a>9.2.4.3 JMS五种消息类型</h5><ul><li>TextMessage, 传String</li><li>BytesMessage, 传byte[]</li><li>MapMessage, 传Map</li><li>StreamMessage, 传消息流</li><li>ObjectMessage, 传可序列化对象(Serializable)</li></ul><h3 id="9-3-ZooKeeper"><a href="#9-3-ZooKeeper" class="headerlink" title="9.3 ZooKeeper"></a>9.3 ZooKeeper</h3><ul><li>[只看一即可]<a href="https://blog.csdn.net/l18848956739/article/details/90666648" target="_blank" rel="noopener">https://blog.csdn.net/l18848956739/article/details/90666648</a></li></ul><h3 id="9-4-RPC"><a href="#9-4-RPC" class="headerlink" title="9.4 RPC"></a>9.4 RPC</h3><h4 id="9-4-1-基本"><a href="#9-4-1-基本" class="headerlink" title="9.4.1 基本"></a>9.4.1 基本</h4><ul><li><a href="https://www.jianshu.com/p/2accc2840a1b" target="_blank" rel="noopener">https://www.jianshu.com/p/2accc2840a1b</a></li><li><a href="https://www.cnblogs.com/winner-0715/p/5847638.html" target="_blank" rel="noopener">为什么需要RPC</a></li></ul><h4 id="9-4-2-原理"><a href="#9-4-2-原理" class="headerlink" title="9.4.2 原理"></a>9.4.2 原理</h4><ul><li><a href="https://www.cnblogs.com/swordfall/p/8683905.html" target="_blank" rel="noopener">https://www.cnblogs.com/swordfall/p/8683905.html</a></li></ul><h4 id="9-4-3-Dubbo"><a href="#9-4-3-Dubbo" class="headerlink" title="9.4.3 Dubbo"></a>9.4.3 Dubbo</h4><h5 id="9-4-3-1-什么是Dubbo"><a href="#9-4-3-1-什么是Dubbo" class="headerlink" title="9.4.3.1 什么是Dubbo"></a>9.4.3.1 什么是Dubbo</h5><ul><li>Dubbo是一个分布式服务框架</li></ul><h5 id="9-4-3-2-为什么要使用Dubbo"><a href="#9-4-3-2-为什么要使用Dubbo" class="headerlink" title="9.4.3.2 为什么要使用Dubbo"></a>9.4.3.2 为什么要使用Dubbo</h5><ul><li>Dubbo实现了RPC, 且提供分布式支持</li></ul><h5 id="9-4-3-3-Dubbo-工作原理"><a href="#9-4-3-3-Dubbo-工作原理" class="headerlink" title="9.4.3.3 Dubbo 工作原理"></a>9.4.3.3 Dubbo 工作原理</h5><ul><li>通过Zookeeper找到所有Dubbo节点,然后通过负载均衡选择某一个节点进行操作</li></ul><h5 id="9-4-3-4-负载均衡"><a href="#9-4-3-4-负载均衡" class="headerlink" title="9.4.3.4 负载均衡"></a>9.4.3.4 负载均衡</h5><ul><li><a href="https://www.cnblogs.com/twoheads/p/10131656.html" target="_blank" rel="noopener">https://www.cnblogs.com/twoheads/p/10131656.html</a></li></ul><h5 id="9-4-3-5-ZooKeeper宕机与dubbo直连的情况"><a href="#9-4-3-5-ZooKeeper宕机与dubbo直连的情况" class="headerlink" title="9.4.3.5 ZooKeeper宕机与dubbo直连的情况"></a>9.4.3.5 ZooKeeper宕机与dubbo直连的情况</h5><ul><li>有两种连接方式, 一种是直连, 直接指定dubbo节点的地址, 一种是zookeeper, 使用负载均衡选择dubbo节点</li><li>如果zookeeper挂了, 可以通过本地缓存继续提供服务</li></ul><h3 id="9-5-布隆过滤器"><a href="#9-5-布隆过滤器" class="headerlink" title="9.5 布隆过滤器"></a>9.5 布隆过滤器</h3><ul><li><a href="https://www.jianshu.com/p/2104d11ee0a2" target="_blank" rel="noopener">https://www.jianshu.com/p/2104d11ee0a2</a></li></ul><h3 id="9-6-分布式一致性"><a href="#9-6-分布式一致性" class="headerlink" title="9.6 分布式一致性"></a>9.6 分布式一致性</h3><ul><li><a href="https://www.cnblogs.com/mayundalao/p/11798502.html" target="_blank" rel="noopener">https://www.cnblogs.com/mayundalao/p/11798502.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/25933039?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25933039?from_voters_page=true</a></li><li><a href="https://zhuanlan.zhihu.com/p/31780743" target="_blank" rel="noopener">Poxos</a></li><li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">Raft</a></li></ul><h2 id="10-算法"><a href="#10-算法" class="headerlink" title="10 算法"></a>10 算法</h2><ul><li><a href="https://github.com/TheAlgorithms/Java" target="_blank" rel="noopener">All Algorithms implemented in Java</a></li><li><a href="https://github.com/TheAlgorithms/Python" target="_blank" rel="noopener">All Algorithms implemented in Python(不用看)</a></li><li><a href="https://leetcode-cn.com/explore/interview/card/top-interview-quesitons-in-2018/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/interview/card/top-interview-quesitons-in-2018/</a></li><li><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation</a></li><li><a href="https://zhuanlan.zhihu.com/p/85197826" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85197826</a></li></ul><h3 id="10-1-数据结构"><a href="#10-1-数据结构" class="headerlink" title="10.1 数据结构"></a>10.1 数据结构</h3><ul><li><a href="https://blog.csdn.net/Nessie_zhao/article/details/80333570" target="_blank" rel="noopener">常见树1</a></li></ul><h3 id="10-2-基本类型"><a href="#10-2-基本类型" class="headerlink" title="10.2 基本类型"></a>10.2 基本类型</h3><ul><li>递归</li><li>分治<blockquote><p>全排列、二分搜索、归并排序、快速排序、线性时间选择、最接近点对问题</p></blockquote></li><li>动态规划, 备忘录方法<blockquote><p>矩阵连乘问题、最长公共子序列问题、0-1背包问题</p></blockquote></li><li>贪心<blockquote><p>活动安排问题、背包问题、装载问题、哈夫曼编码、单源最短路径、最小生成树问题</p></blockquote></li><li>回溯法<blockquote><p>n后问题、0-1背包问题、旅行售货商问题</p></blockquote></li><li>分支限界法<blockquote><p>0-1背包问题、旅行售货商问题</p></blockquote></li></ul><h3 id="10-3-常见问题"><a href="#10-3-常见问题" class="headerlink" title="10.3 常见问题"></a>10.3 常见问题</h3><ul><li>常见的排序算法, 及其空间时间的复杂度</li><li>查找值范围在[x,y]的乱序的n个数字当中唯一”出现2次”的数字(空间换时间)</li><li>二叉树的深度和广度遍历(最好是非递归)(队列和栈的使用)</li><li>找出二叉树上两个距离最远的节点</li><li>数组的全排列(递归)</li><li>计算一个数字的N次幂</li><li>海量数据的Top N(堆的使用)</li><li>生产者消费者代码</li><li>阻塞队列实现</li><li>线程间通信</li><li>完全二叉树的节点个数(完全二叉树的理解)</li><li>将一个正整数拆成n个数之和, 使得积最大(动态规划)</li><li>求一个字符串的最大无重复子串(动态规划)</li><li>找出一个int数组中, 乘积最大的连续子数组, 数组值包含正负</li><li>找出最长上升子序列(不需要连续), 得出最长值就可以</li><li>现有每只股票的跌涨数据, 请设计算法找出涨幅最高的十只股票(Top N)</li><li>现在中意n支股票, 现投顾手中共有用户的资产为m元, 投顾只想每支股票最多买一支, 且买到的股票总价格正好为m元。请你设计算法, 判断投顾能不能成功(背包问题, 动态规划)</li><li>最大回撤率<blockquote><ul><li>最大回撤: 在某一段时期内产品净值从最高点开始回落到最低点的幅度</li><li>最大回撤率: $max (Di-Dj) / Di$ $(i &lt; j)$</li><li>求最大回撤率, O(n)</li></ul></blockquote></li></ul><h2 id="11-系统设计"><a href="#11-系统设计" class="headerlink" title="11. 系统设计"></a>11. 系统设计</h2><h3 id="11-1-业务系统核心架构图"><a href="#11-1-业务系统核心架构图" class="headerlink" title="11.1 业务系统核心架构图"></a>11.1 业务系统核心架构图</h3><ul><li><a href="https://www.jianshu.com/p/9389301b0bc8" target="_blank" rel="noopener">https://www.jianshu.com/p/9389301b0bc8</a></li></ul><h3 id="11-2-如何保证DB和缓存的一致性"><a href="#11-2-如何保证DB和缓存的一致性" class="headerlink" title="11.2 如何保证DB和缓存的一致性"></a>11.2 如何保证DB和缓存的一致性</h3><ul><li><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9041659.html</a></li><li><a href="https://www.cnblogs.com/itsoku123/p/11718164.html" target="_blank" rel="noopener">https://www.cnblogs.com/itsoku123/p/11718164.html</a></li></ul><h3 id="11-3-缓存使用的关注点"><a href="#11-3-缓存使用的关注点" class="headerlink" title="11.3 缓存使用的关注点"></a>11.3 缓存使用的关注点</h3><ul><li><a href="http://stor.51cto.com/art/201812/589539.htm" target="_blank" rel="noopener">http://stor.51cto.com/art/201812/589539.htm</a></li></ul><h3 id="11-4-设计一个高吞吐量的系统"><a href="#11-4-设计一个高吞吐量的系统" class="headerlink" title="11.4 设计一个高吞吐量的系统"></a>11.4 设计一个高吞吐量的系统</h3><ul><li><a href="https://my.oschina.net/u/2246792/blog/511392" target="_blank" rel="noopener">https://my.oschina.net/u/2246792/blog/511392</a></li></ul><h3 id="11-5-微信发红包设计方案"><a href="#11-5-微信发红包设计方案" class="headerlink" title="11.5 微信发红包设计方案"></a>11.5 微信发红包设计方案</h3><ul><li><a href="https://www.jianshu.com/p/87c98fd7ceef" target="_blank" rel="noopener">https://www.jianshu.com/p/87c98fd7ceef</a></li></ul><h3 id="11-6-限流-降级-高可用-容灾-水平扩容等"><a href="#11-6-限流-降级-高可用-容灾-水平扩容等" class="headerlink" title="11.6 限流, 降级, 高可用, 容灾, 水平扩容等"></a>11.6 限流, 降级, 高可用, 容灾, 水平扩容等</h3><h4 id="11-6-1-限流-降级"><a href="#11-6-1-限流-降级" class="headerlink" title="11.6.1 限流, 降级"></a>11.6.1 限流, 降级</h4><ul><li><a href="https://www.cnblogs.com/binyue/p/11596763.html" target="_blank" rel="noopener">https://www.cnblogs.com/binyue/p/11596763.html</a></li></ul><h4 id="11-6-2-高可用"><a href="#11-6-2-高可用" class="headerlink" title="11.6.2 高可用"></a>11.6.2 高可用</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959728&idx=1&sn=933227840ec8cdc35d3a33ae3fe97ec5&chksm=bd2d046c8a5a8d7a13551124af36bedf68f7a6e31f6f32828678d2adb108b86b7e08c678f22f&scene=21#wechat_redirect" target="_blank" rel="noopener">链接1</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959830&idx=1&sn=ce1c5a58caed227d7dfdbc16d6e1cea4&chksm=bd2d07ca8a5a8edc45cc45c4787cc72cf4c8b96fb43d2840c7ccd44978036a7d39a03dd578b5&scene=21#wechat_redirect" target="_blank" rel="noopener">链接2</a></li></ul><h4 id="11-6-3-容灾-水平扩容"><a href="#11-6-3-容灾-水平扩容" class="headerlink" title="11.6.3 容灾, 水平扩容"></a>11.6.3 容灾, 水平扩容</h4><ul><li><a href="https://www.jianshu.com/p/6b342357d6ef" target="_blank" rel="noopener">https://www.jianshu.com/p/6b342357d6ef</a></li><li><a href="https://www.jianshu.com/p/be66a52d2b9b" target="_blank" rel="noopener">https://www.jianshu.com/p/be66a52d2b9b</a></li></ul><h3 id="11-7-负载均衡"><a href="#11-7-负载均衡" class="headerlink" title="11.7 负载均衡"></a>11.7 负载均衡</h3><ul><li><a href="https://www.jianshu.com/p/7b2b9d646746" target="_blank" rel="noopener">只看一就行</a></li></ul><h3 id="11-8-一致性哈希的原理"><a href="#11-8-一致性哈希的原理" class="headerlink" title="11.8 一致性哈希的原理"></a>11.8 一致性哈希的原理</h3><ul><li><a href="https://www.cnblogs.com/756623607-zhang/p/6656047.html" target="_blank" rel="noopener">https://www.cnblogs.com/756623607-zhang/p/6656047.html</a></li></ul><h3 id="11-9-分布式事务"><a href="#11-9-分布式事务" class="headerlink" title="11.9 分布式事务"></a>11.9 分布式事务</h3><ul><li>CAP<blockquote><ul><li>C：Consistency，一致性，所有数据变动都是同步的。</li><li>A：Availability，可用性，即在可以接受的时间范围内正确地响应用户请求。</li><li>P：Partition tolerance，分区容错性，即某节点或网络分区故障时，系统仍能够提供满足一致性和可用性的服务。</li></ul></blockquote></li><li><a href="https://www.cnblogs.com/luxiaoxun/p/8832915.html" target="_blank" rel="noopener">看到三.1就行了</a></li></ul><h2 id="12-其他"><a href="#12-其他" class="headerlink" title="12. 其他"></a>12. 其他</h2><ul><li><a href="https://zhuanlan.zhihu.com/c_1046719595074949120" target="_blank" rel="noopener">必须深入理解的50个JAVA基础概念(只有13个))</a></li><li><a href="https://mp.weixin.qq.com/s/dTHL4bUECWden6MdMbJxpg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dTHL4bUECWden6MdMbJxpg</a></li><li><a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">https://github.com/crossoverJie/JCSprout</a></li><li><a href="https://www.zhihu.com/question/31032841/answer/668144642" target="_blank" rel="noopener">https://www.zhihu.com/question/31032841/answer/668144642</a></li><li>看过哪些书, 学过哪些新技术</li><li>技术分享</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
